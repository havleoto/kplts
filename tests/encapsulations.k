;;;
;;; encapsulations.k
;;;
;;; Test make-encapsulation-type.
;;;

($test-group encapsulations
    ((cite (kernel-report 8))
     (plan encapsulated-data-type equality make-encapsulation-type))

  ($test-group encapsulated-data-type
      ((cite (kernel-report 8)
             "Kernel data type /encapsulation/ is encapsulated.")
       (number 10))
    ($define! (enc . #ignore) (make-encapsulation-type))
    ($define! obj (enc ()))
    (for-each
      ($lambda (p?) ($check equal? (p? obj) #f))
      (list boolean? symbol? inert? pair? null? environment?
            ignore? operative? applicative? combiner?)))

  ($test-group equality
      ((cite (kernel-report 8)
             "Two encapsulations are equal? iff they are eq?")
       (require-standard-bindings eq?)
       (number 36))
    ($define! (e1 . #ignore) (make-encapsulation-type))
    ($define! (e2 . #ignore) (make-encapsulation-type))
    ($define! objects
      (list (e1 ()) (e1 ()) (e1 e1)
            (e2 ()) (e2 ()) (e2 e1)))
    (for-each
      ($lambda ((x y)) ($check equal? (equal? x y) (eq? x y)))
      (list-product objects objects)))

  ($test-group make-encapsulation-type
      ((cite (kernel-report 8 1 1))
       (plan return-value fresh-methods encapsulator predicate decapsulator))

    ($test-group return-value
        ((cite (kernel-report 8 1 1)
               "returns a list of the form (e p? d), where e, p?, and d are
                applicatives")
         (number 5))
      ($define! return-value (make-encapsulation-type))
      ($check (finite-list? return-value))
      ($check equal? (length return-value) 3)
      ($define! (e p? d) return-value)
      ($check (applicative? e))
      ($check (applicative? p?))
      ($check (applicative? d)))

    ($test-group fresh-methods
        ((cite (kernel-report 8 1 1)
               "each call to make-encapsulation-type returns different applicatives
                e, p?, and d")
         (number 3))
      ($define! (e1 p1? d1) (make-encapsulation-type))
      ($define! (e2 p2? d2) (make-encapsulation-type))
      ($check (not? (equal? e1 e2)))
      ($check (not? (equal? p1? p2?)))
      ($check (not? (equal? d1 d2))))

   ($test-group encapsulator
       ((plan fresh-object error-handling))

     ($test-group fresh-object
         ((cite (kernel-report 8 1 1)
                "Encapsulations returned on different occasions are not eq?.")
          (require-standard-bindings eq?)
          (number 3))
       ($define! (e . #ignore) (make-encapsulation-type))
       ($define! a (e ()))
       ($define! b (e 1))
       ($define! c (e e))
       ($check (not? (eq? a b)))
       ($check (not? (eq? b c)))
       ($check (not? (eq? c a))))

     ($test-group error-handling
         ((cite (kernel-report 8 1 1)
                "/e/ is an applicative that takes one argument")
          (number 7))
       ($check-error ((car (make-encapsulation-type))))
       ($check-error ((car (make-encapsulation-type)) 1 2))
       ($check-error ((car (make-encapsulation-type)) 1 2 3))
       ($check-error ((car (make-encapsulation-type)) 1 2 3 4))
       ($check-error (apply (car (make-encapsulation-type)) ()))
       ($check-error (apply (car (make-encapsulation-type)) (list 1 2)))
       ($check-error ((unwrap (car (make-encapsulation-type))) . c))))

   ($test-group predicate
       ((cite (kernel-report 8 1 1)
              "p? [...] takes zero or more arguments and returns
               true iff all of them are encapsulations generated by /e/")
        (number 12))
     ($define! (e p? #ignore) (make-encapsulation-type))
     ($define! (f . #ignore) (make-encapsulation-type))
     ($check (p?))
     ($check (p? (e ())))
     ($check (p? (e 1) (e 2)))
     ($check (p? (e 1) (e 2) (e 3)))
     ($check (p? (e 1) (e 2) (e 3) (e 4)))
     ($check (not? (p? (f ()))))
     ($check (not? (p? (e 1) (f 2) (e 3))))
     ($check (not? (p? ())))
     ($check (not? (p? 1)))
     ($check (not? (p? (list 1 2))))
     ($check (not? (p? e)))
     ($check (not? (p? (make-environment)))))

   ($test-group decapsulator
         ((plan return-content one-argument type-mismatch))

     ($test-group return-content
         ((cite (kernel-report 8 1 1)
                "content of the encapsulation is returned")
          (number 2))
       ($define! (e #ignore d) (make-encapsulation-type))
       ($check equal? (d (e 1)) 1)
       ($check equal? (d (e 2)) 2))

     ($test-group one-argument
         ((cite (kernel-report 8 1 1)
                "d is an applicative that takes one argument")
          (number 7))
       ($define! (e #ignore d) (make-encapsulation-type))
       ($check-error (d))
       ($check-error (d (e 1) (e 2)))
       ($check-error (d (e 1) (e 2) (e 3)))
       ($check-error (d (e 1) (e 2) (e 3) (e 4)))
       ($check-error (apply d (list (e 1) (e 2))))
       ($check-error (apply d (list (e 1) (e 2) (e 3))))
       ($check-error (eval (list (unwrap d) (e 1) (e 2)) (get-current-environment))))

     ($test-group type-mismatch
         ((cite (kernel-report 8 1 1)
                "if the argument is not an encapsulation generated by /e/,
                 an error is signaled")
          (number 4))
       ($define! (#ignore #ignore d) (make-encapsulation-type))
       ($define! (f #ignore #ignore) (make-encapsulation-type))
       ($check-error (d 0))
       ($check-error (d (list 1 2)))
       ($check-error (d (make-environment)))
       ($check-error (d (f 0)))))))
